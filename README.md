# Compiler

### 功能实现

基于llvm-3.6实现了基本C语言的编译器，可支持如下功能：

1. int, float 基本类型, 它们都会有常量控制. 

    (常量控制的含义是, 对于赋值语句 a = b 而言, 若 a 是 const 变量, 则 b 必须也是 const 变量或者其他常量表达式; 而如果 a 不是 const 变量, 那么 b 就没有限制. 对于 const 变量还需要有一些其他的控制, 比如不能在后续中被赋值. 在 llvm 的 IR 中并没有体现局部的 const 变量. 全局的 const变量有 constant 修饰. 这样就需要单独进行一些控制, 比如记录下所有的 const 变量, 在赋值语句中查看左值是否为 const.)

2. 数组, 数组的长度可以由常量决定, 也可以由 const 变量决定, 如果该项未明确, 则由后面的初始化列表长度来决定.

3. if 条件判断和 while 循环, 其中加入了 break/continue 语句, 允许从深层跳出.

4. extern 变量及函数, 最开始是用于静态库的打印函数

5. 支持带参数的函数调用和返回值, 返回值可以是 void, int, float 类型

6. 支持指针类型, 即可以使用 * 作为指针声明的标志, 可以使用 & 取变量的地址, 同时也允许指针之间的赋值. 能够取数组某一元素的地址给指针变量赋值. 指针变量能够取其所指向的值.

7. 指针可以作为函数的参数, 也能作为返回值(好像 llvm 中 PointerType 和 ArrayType并不能在某种程度上统一, 因此我一直希望能通过数组的 GEP 方式访问指针的方法失败了, 就把这里的指针当成仅仅作为能指向某个类型元素地址的类型了)

8. 支持结构体类型, 这里的结构体类型需要在函数外声明作为一个全局类型. 结构体元素支持了 int,  float, int \*, float \*, int [], float [], 还有 struct \*(这样能够构成近似的链表). 在结构体中可以用 '.'来获取某一个元素. 对结构体的赋值也可以直接对整个结构体赋值, 也可以为为结构体的某一项赋值. (为了赋值的方便, 在这里允许给指针赋值为0, 表明它是一个空指针)

9. 指针能够指向结构体, 和其他类型一样都能使用 * , & 操作符, 但是由于不能支持->操作, 因此有很多东西无法实现. 结构体也能做函数的参数.

10. 可以使用结构体数组. 但是没有考虑嵌套情况, 即结构体中没有考虑其他结构体作为其中的一项, 数组中没有考虑高维数组.


### 运行示例

  `./run.sh`

